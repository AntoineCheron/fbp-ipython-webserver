---
layout: default
id: Kernel
title: Backend API
parent: backend-api
---
# Documentation

## `public class Kernel`

The kernel is the element that runs the python code and decide when it is needed to inform every interface of the executed code, the result, that it is busy, idle, etc.

5 channels are used to communicate with the fr.irisa.diverse.Core.Kernel (see fr.irisa.diverse.Jupyter.JupyterMessaging in Jupyter doc to know more about it).

The kernel is embedded into a Docker container, which creates a connexion_file that this class will read to know on which ports to connect the sockets.

IMPORTANT : 1 kernel per node, 1 node per kernel. It is a 1-1 relation.

Created by antoine on 28/04/17.

## `public void stop ()`

Stop the kernel and its linked Docker container.

## `public void stopExecution ()`

Stop the execution of kernel, not the container

## `public void verifyChannelsAreOk ()`

Verify that we are still connected to the 5 channels. If not restart them. TODO : the restart feature

## `public void handleExecutionResult (String[] result)`

Do what's needed when receiving the result of the execution of a code. It verify that we were waiting for this response and store the result into the node.

 * **Parameters:** `result` — : the result received from the channel's stdout

## `public void executeCode (String code, Node node)`

Require the kernel to execute a code on the Jupyter Kernel.

 * **Parameters:** `code` — : the code to execute

## `private void startContainer() throws FailedKernelStartException`

Start the container. Must be called only while creating a new instance of Kernel.

 * **Exceptions:** `FailedKernelStartException` — : exception telling that the kernel failed starting.

## `private void stopContainer ()`

Stop the container linked to this kernel. Usually called when stopping the whole server.

## `private void startChannels ()`

Start the 5 ZMQ channels that communicate with the Jupyter kernel that is inside a Docker container.

## `private void stopChannels()`

Stop and close the 5 ZMQ channels and their Thread.

## `private void verifyChannelIsOk(JupyterChannel channel)`

Verify that a channel is running and connected

 * **Parameters:** `channel` — : the channel to check

## `private void createChannelsFromConnexionFile (String path) throws InterruptedException, FailedRetrievingContainerIPException, ParseException, IOException`

Create the ZMQ sockets and configure their properties and endpoints from a connexion_file. This connexion_file is generated by the code of the Jupyter kernel inside the Docker container.

The name of the connexion_file is {{containerId}}.json

 * **Parameters:** `path` — : the absolute Path to the connexion_file
 * **Exceptions:**
   * `InterruptedException` — : Exception from Thread, can be thrown if interrupted while sleeping.
   * `FailedRetrievingContainerIPException` — : Thrown if impossible to retrieve the container's IP
   * `ParseException` — : Thrown if impossible to parse the File at the given path.
   * `IOException` — : Look at Javadoc.

## `public String getContainerId ()`

The container id is an ID associated to a running container by the docker daemon

 * **Returns:** : the id of the running container associated to the instance of kernel.

## `public String getSession ()`

The session is a String only used to communicate on the Jupyter messaging protocol

 * **Returns:** : the String session

## `public void setSession(String session)`

The session is a String only used to communicate on the Jupyter messaging protocol

 * **Parameters:** `session` — : the new session string to use

## `public String getIdentity ()`

The identity is a String only used to communicate on the Jupyter messaging protocol

 * **Returns:** : String containing the identity

## `public void setIdentity (String identity)`

The identity is a String only used to communicate on the Jupyter messaging protocol

 * **Parameters:** `identity` — (String) the new identity to use

## `public String getSignatureScheme ()`

The signature scheme is a parameter to build the HMAC used to communicate on the Jupyter message protocol. Google it for more information, it is a very common concept.

 * **Returns:** (String) containing the signature scheme

## `public String getKey ()`

The key to give to the algorithm creating the HMAC

 * **Returns:** (String) the key to use

## `public void setNbExecutions (Long nbExecutions)`

nbExecutions is the number of executions the kernel did. Called only by the JupyterMessaging.manager to update the nb of execution when receiving an execute_reply msg.

 * **Parameters:** `nbExecutions` — : the new number of execution. Usually nbExecution + 1

## `public Long getNbExecutions ()`

nbExecutions is the number of executions the kernel did.

 * **Returns:** (Long) the nb of executions

## `public boolean isIdle ()`

Tells whether the Kernel is idle or running. Idle means the shell is not doing calculations.

 * **Returns:** : true if idle

## `public boolean isBusy ()`

Tells whether the Kernel is idle or running. Busy means the shell is doing calculations.

 * **Returns:** true is running (= busy)

## `public void setIdleState (boolean value)`

Set the idle state of the Kernel. Must only be called by the JupyterMessaging.manager when receiving a message on IOPub.

 * **Parameters:** `value` — 

## `public Manager getMessagesManager ()`

Get the message manager. It is used to communicate with the Jupyter kernel.

 * **Returns:** {Manager} the manager used by the kernel.

## `private boolean isIpAddress(String text)`

Regex to know if the given text is an IP Address or not.

 * **Parameters:** `text` — (String) the text that you want to determine if it is an IP Address
 * **Returns:** True if the given text is an IP Address

## `private String retrieveContainerIp() throws FailedRetrievingContainerIPException`

Retrieve the IP of the Docker container linked to this Kernel. Use bash commands to do that.

 * **Returns:** (String) the IP address of the container
 * **Exceptions:** `FailedRetrievingContainerIPException` — : exception telling that it was unable to retrieve the IP.

## `private void deleteConnexionFile ()`

Delete the connexion file. This method is used when stopping the kernel, to make sur that, in case the container did not, we delete the connexion file.
